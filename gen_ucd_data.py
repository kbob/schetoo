#!/usr/bin/python

# Read UnicodeData.txt.
# Read unicode.h.
# Populate gc[] (general category).
# Split gc into pages.
# Write it out.

from collections import defaultdict
import re
import sys


page_size = 256

class Dict1(dict):

    def __setitem__(self, key, value):
        print 'self[%r] = %r' % (key, value)
        assert key not in self
        return super(Dict1, self).__setitem__(key, value)


def read_file(name):
    with open(name) as f:
        for line in f:
            line = line.strip()
            fields = [field.strip() for field in line.split(';')]
            yield fields


def munge_unicodedata(name):
    match_first = re.compile(r'\s*<(.*),\s*First\s*>\s*\Z').match
    match_last = re.compile(r'\s*<(.*),\s*Last\s*>\s*\Z').match
    f = read_file(name)
    for fields in f:
        m = match_first(fields[1])
        if m:
            flast = f.next()
            assert match_last(flast[1])
            assert(flast[2:] == fields[2:])
            fields[0] = fields[0].strip() + '..' + flast[0].strip()
            fields[1] = m.group(1)
        yield fields


def expand_ranges(records):
    match_range = re.compile(r'(?i)([\da-f]{4,6})\.\.([\da-f]{4,6})').match
    for r in records:
        m = match_range(r[0])
        if m:
            first, last = [int(i, 0x10) for i in m.groups()]
            for i in range(first, last + 1):
                yield ['%04X' % i] + r[1:]
        else:
            yield r


def read_cat_map():
    search_cat = re.compile(r'(UGC_\w+).*/\* (\w\w) \*/').search
    cat_map = {}
    for line in open('unicode.h'):
        m = search_cat(line)
        if m:
            cat_map[m.group(2)] = m.group(1)
    return cat_map


def read_unicode_data(filename):
    gc = {}
    for j in expand_ranges(munge_unicodedata('UnicodeData.txt')):
        cp = int(j[0], 0x10)
        cat = j[2]
        gc[cp] = cat
    return gc


def dict_to_list(d, size, default=None):
    l = [default] * size
    for k, v in d.iteritems():
        l[k] = v
    return l


def paginate_data(gc):
    npages = (max(gc) + page_size) / page_size
    size = npages * page_size
    gcl = dict_to_list(gc, size, 'Cn')
    page_map = []
    pages = []
    for i in range(npages):
        page = gcl[page_size * i : page_size * (i + 1)]
        try:
            idx = pages.index(page)
        except ValueError:
            idx = len(pages)
            pages.append(page)
        page_map.append(idx)
    return page_map, pages

'''
int ucd_pages[] = {
     0,  1,  2,  3,     4,  5,  6,  7,  /* U+0000..U+07ff */
    ...
    89, 89, 89, 89,    89, 89, 89, 89,  /* U+43000..U+437ff */
};

xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
int ucd_data[] = {
    /* Pages U+0000..U+0FFF, U+1000..U+1FFF, U+2000..U+2FFF, U+3000..U+3FFF */
    /* Pages U+0000..U+0FFF, U+1000..U+1FFF, U+2000..U+2FFF, U+8000..U+8FFF */
    UGC_LETTER_LOWER,                   /* U+0061, ... */

};
'''

def XXXprint_c_source(gc, cat_map):
    ucd_size = max(gc) + 1
    print '/* Automatically generated by %s.  Do not edit. */' % sys.argv[0]
    print
    print 'static const size_t UCD_SIZE = %d;' % ucd_size
    print
    print 'static const unicode_data_t ucd_data[%d] = {' % ucd_size
    for cp in range(ucd_size):
        s = '{ %s },' % cat_map.get(gc.get(cp), 'UGC_OTHER_NOT_ASSIGNED')
        print '    %-35s /* U+%04X */' % (s, cp)
    print '};'


def invert_list(l):
    """Invert a list.  Return a dictionary mapping each value
       in the list to the indices where it appears
       E.g.,
           invert_list(['red', 'red', 'blue']) => {'red': [0, 1], 'blue': [2]}
    """
    d = {}
    for i, item in enumerate(l):
        d.setdefault(item, []).append(i)
    return d

assert invert_list(['red', 'red', 'blue']) == {'red': [0, 1], 'blue': [2]}


def urange(start, len):
    return 'U+%04X..U+%04X' % (start, start + len - 1)


def print_c_source(page_map, pages, cat_map):
    cp_size = len(page_map) * page_size
    page_to_cp = invert_list(page_map)
    print '/* Automatically generated by %s.  Do not edit. */' % sys.argv[0]
    print
    print 'static const size_t UCD_PAGE_SIZE = %d;' % page_size
    print 'static const size_t UCD_PAGE_COUNT = %d;' % len(page_map)
    print 'static const size_t UCD_CODEPOINT_COUNT = %d;' % cp_size
    print
    print 'static const unsigned char ucd_page_map[] = {'
    for i in range(0, len(page_map), 8):
        z = tuple(page_map[i:i+8])
        s = '    %2d, %2d, %2d, %2d,   %2d, %2d, %2d, %2d,' % z
        print '%-40s/* %s */' % (s, urange(i * page_size, 8 * page_size))
    print '};'
    print
    print 'static const unicode_data_t ucd_data[] = {'
    for i, page in enumerate(pages):
        cps = page_to_cp[i]
        etc = '' if len(cps) == 1 else ', ...'
        for j in cps:
            print '    /* Page %s */' % urange(j * page_size, page_size)
        for j, cat in enumerate(page):
            cp = cps[0] * page_size + j
            s = '{ %s },' % cat_map.get(cat, 'UGC_OTHER_NOT_ASSIGNED')
            print '    %-35s /* U+%04X%s */' % (s, cp, etc)
        print
    print '};'


def main():
    cat_map = read_cat_map()
    gc = read_unicode_data('UnicodeData.txt')
    page_map, pages = paginate_data(gc)
    print_c_source(page_map, pages, cat_map)


if __name__ == '__main__':
    main()

