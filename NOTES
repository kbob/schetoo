Note 1: Give up on saving a word on pairs.  Just give them a normal
type record.  Revisit later if you really want to.

Note 2: Unify the rdt and the mem_ops_t.  Give them the same layout,
maybe with some fields unused.  Then the heap copying code doesn't
have to special case record instances.  Add an "I am not in the heap"
flag somewhere, so the copier can ignore out-of-heap rdts.

----------------------------------
2010.01.17

If we're going to use the C reader with Scheme I/O, we need a general
way for C to call Scheme.  I think.

----------------------------------
2010.01.18

Time to refactor mem.h.  First cut: three kinds of data -- whole heap
operations, things that are needed for obj definitions, and things
that are needed throughout the interpreter.

Whole heap stuff (heap.h?)
	set_heap_size_bytes()
	init_heap()
	
Obj definition stuff (mem.h?):
	heap_object_t
	OBJ_ALIGN
	is_forward()
	is_immediate()
	is_special()
	obj_heap_ptr()
	obj_fwd_ptr()
	heap_object_set_fwd_ptr()
	mem ops
	mem_ops_t definition
	heap_object
	obj_heap_object()
	heap_obect_mem_ops()
	obj_mem_ops()
	is_primitive_obj()
	is_record_instance()
	CHECK_OBJ, check_obj
	mem_alloc_obj

Global stuff (obj.h? object.h?):
	obj_t
	word_t
	masks, tags, shifts, and bits
	obj_bits()
	macros to create chars, bools, and reader constants
	FALSE_OBJ (obj_boolean.h?)
	TRUE_OBJ (obj_boolean.h?)
	EMPTY_LIST (obj_null.h?)
	UNDEFINED (obj_undefined.h?)
	END_OF_FILE (obj_???)
	MEM_OPS_PRIMITIVE
	READER_CONSTANT - rename to READER_ACTION?
	is_heap()
	is_null() (obj_null.h?)
	is_undefined (obj_undefined.h)
	mem_ops_t declaration
	obj_type_name()

----------------------------------
2010.01.25

Work interferes.

Trying to decide what the next big step should be.  I wanted to
implement continuations as records, which means I need records next.
Or I could just do continuations ad-hoc and move on to eval.

I've been thinking about the problem of calling Scheme from C.  I
can't just call eval() from arbitrary places because (a) eval() uses a
static jmp_buf to recover from exceptions, and (b) I'm trying to have
a hard bound on C stack size.

So I reviewed the C coroutine literature.
http://en.wikipedia.org/wiki/Coroutine#Implementations_for_C
http://www.chiark.greenend.org.uk/~sgtatham/coroutines.html

Nothing there appears to be directly applicable.  So for now, the rule
is, C does not call Scheme (except once at the top level).

So let's talk about eval.  One question to answer is, what happens
when a procedure is applied to some arguments?  The old Scheme
interpreter had some complex mumbo-jumbo where it built the arg list
in place as each arg was evaluated, and then the procedure was called.

I'm envisioning four registers.

    CONT is the continuation register.  It points to the current
    eval's continuation.  Think of it as a return PC.

    TBE is to-be-evaluated.  It points to a LIFO list of expressions
    to evaluate.

    VALUES points to a LIFO list of values of past evaluations.

    ENV is the current environment.

Eval's basic operation is to pop one item off TBE, evaluate it,
push the result onto VALUES, and then jump to CONT.

For self-evaluating expressions, that's pretty easy.

    def eval(expr):
        expr = TBE.pop()
        if expr.is_self_evaluating():
            VALUES = cons(expr, VALUES)
        elif ...
            ...
        goto CONT

For symbols, it's just a lookup in the current environment.

        ...
        elif expr.is_symbol():
            VALUES = cons(ENV.lookup(expr), VALUES)
        ...

For applications (aka procedure calls), we need to push a continuation
to apply the operator to its args and then push more continuations to
evaluate each of the arguments.  (Ignore special forms for now.)

        ...
        elif expr.is_application():
            CONT = make_continuation(code=apply,
                                     arg=expr,
                                     arg2=VALUES,
                                     env=ENV,
                                     cont=CONT)
            for arg in expr.arguments():
                CONT = make_continuation(code=eval,
                                         arg=arg,
                                         env=ENV,
                                         cont=CONT)
        ...

Then apply looks something like this.

    def apply(expr, eoargs):
        # Reverse and null-terminate the argument list
        args = nil
        while VALUES != eoargs:
            args = cons(car(VALUES), args)
            VALUES = cdr(VALUES)
        CONT = make_continuation(code=expr.operator(),
                                 env=push_env(expr.arglist, args, ENV),
                                 cont=CONT)

Something like that.

Meanwhile, there is a large number of primitives.  It would be grand
if we had a simple ABI for simple primitives.  Something like this.

    obj_t my_primitive(obj_t arg1, obj_t arg2)
    {
         return <return value>;
    }

Maybe wrap a macro around that to bind a symbol to the procedure.

    DEFINE_SIMPLE_PROC("my-primitive", 2)(obj_t arg1, obj_t arg2)
    {
        return <return value>;
    }

----------------------------------
2010.01.29

Alternative eval VM.

An "instruction" has a varying number of fields (operands).  Two
fields are always included: proc is the C procedure that implements
the instruction, and cont is the address of the next instruction
(continuation).

An instruction manipulates the three global registers, VALUES, ENV,
and CONT.  VALUES is a list of values of previously evaluated
expressions.  ENV is the current environment.  CONT points to the
next instruction.

A self-eval instruction evaluates a self-evaluating expression.  It
has three fields. proc = eval_const, expr = the self-evaluated
expresion, and cont = whatever.  The self_eval procedure looks like
this.

    void eval_const(obj_t inst)
    {
        VALUES.push(inst.arg);
	CONT = CONT.cont
    }

Each instruction the result of evaluating its expression.

A eval_symbol instruction evaluates a symbol.  It uses the global
register ENV.  The three fields are proc = eval_sym, arg = the symbol,
and cont.

    void eval_sym(obj_t inst)
    {
        VALUES.push(lookup(inst.arg, ENV);)
    }

An application instruction applies a procedure to a symbol.  It has
three fields: proc = eval_app, arg = VALUES, and cont = whatever.
eval_app looks like this.

    void eval_app(obj_t inst)
    {
        CONT = make_instruction(finish_apply, VALUES, CONT);
	/* go on to evaluate the first arg which pushes onto VALUES. */
    }

    void finish_apply(obj_t inst)
    {
        obj_t proc = VALUES.pop();
        ENV.push(make_env(proc.arglist, VALUES, inst.arg));
	proc = VALUES.pop();
    }

This doesn't work.  Need to check, after proc has been evaluated, whether
its args should be evaluated.

----------------------------------
2010.01.30

Need a new layer between except and eval.  Something to handle
all the various reasons to call longjmp().  Call it low-level
exceptions.  lowex.h.

Considering yesterday's idea.  Wondering whether "instruction" is the
right term.  Might also be appropriate to call it a "continuation".


---

Condition Index.  Every place in r6rs that mentions raising an exception.

r6rs 4.2.6: &lexical  - #\x0001z
                      - #\Î»x
		      - #\alarmx
		      - #\Alarm
		      - #\alert
		      - #\(x)
		      - #\(x
		      - #\x00110000
		      - #\xD800
r6rs 4.2.7: &lexical  - "\x41"
     	    	      - "\x;"
		      - "\x41bx;"
		      - "\x00110000;"
		      - "\xD800;"
r6rs 5.10: &assertion - writing immutable object.
     	   	      - writing literal constant
		      - writing symbol name
		      - writing record w/ no mutable field
r6rs 6.1: &syntax     - syntax called with wrong kind of argument
     	  	      - syntax called with wrong shape of form
r6rs 6.2: &assertion  - procedure called with wrong kind of argument
     	  	      - procedure called with wrong number of arguments
r6rs 6.6: &assertion  - (integer->char #xD800)
r6rs 9.1: &assertion  - operator of application is not a procedure
r6rs 9.1: &assertion  - application wrong number of arguments
r6rs 11.2.1: &assertion - continuation of rhs of define invoked more than once
r6rs 11.4.6: &assertion - <init> in letrec refers to other variable
     	     	      - <init> in letrec* refers to later variable
		      - <init> in letrec* invoked more than once
		      - <formals> doesn't match <init> in let-values
r6rs 11.7.2: &no-infinities - if FPU doesn't support Inf
             &no-nans - if FPU doesn't support NaN
r6rs 11.7.4: &implementation-violation - if exact->inexact fails
     	     	      - if inexact->exact fails
		      - if min or max fails to compare exact vs inexact
		      - if + or * called with mixed non-rational real and
		        non-real complex arguments
		      - if - called with mixed non-rational real and
		        non-real complex arguments
		      - if / called with mixed non-rational real and
		        non-real complex arguments
	   &assertion - (/ 0 0)
	   	      - (/ 3 0)
	   &assertion - if divisor is zero or dividend is Nan or Inf.
	   	      - (log 0.0)
	   &implementation-restriction - if can't raise 0.0 to negative power
	   			       - if can't convert float to string
r6rs 11.9: &assertion  - on (car '())
     	   	       - on (cdr '())
r6rs 11.11: &assertion - (integer->char #\xD800)
r6rs 11.13: &assertion - if vector-set! passed an immutable vector
     	    	       - (vector-set! '#(0 1 2) 1 "doe")
r6rs 11.14: &assertion - if user assertion fails
	 	       - (fac 4.5)
     		       - (fac -3)
r6rs 11.19: &syntax    - (set! p.car 15)
r6rs-lib 3: &assertion - (for-all even? '(2 4 14 . 9))
	    	       - (exist even? '(3 1 1 5 9 . 2))
r6rs-lib 5: &assertion - if case-lambda doesn't match
r6rs-lib 6.2: &assertion - if two nongenerative record types don't match
r6rs-lib 6.3: &assertion - if a sealed record type is subclassed
	      		 - if two nongenerative record types don't match
			 - if record-rtd called for opaque record
			 - if mutator for immutable record field requested
			 - if record-mutator called for immutable field
			 - if record-rtd called for opaque record
r6rs-lib 7.1: &non-continuable - if exception handler returns
r6rs-lib 7.3: &undefined - unbound identifier
r6rs-lib 8.1: &i/o-read - read error
	      &i/o-write - write error
	      &i/o-invalid-position - seek error
	      &i/o-filename - error on a named file
	      &i/o-file-protection - EPERM
	      &i/o-file-is-read-only - tried to write read-only file
	      &i/o-file-already-exists - tried to create existing file
	      &i/o-file-does-not-exist - tried to open nonexistent file
	      &i/o-port - procedures accepting a port as an argument
r6rs-lib 8.2.2: &i/o-file-already-exists - sometimes when output file opened
                &i/o-file-does-not-exist - sometimes when output file opened
r6rs-lib 8.2.4: &i/o-decoding - on character decoding error
	 	&i/o-encoding - on character encoding error
r6rs-lib 8.2.6: &assertion - ftell on unseekable port
	 		   - fseek on unseekable port
                &i/o-invalid-position - seek to invalid position
				      - seek on non-binary file
r6rs-lib 8.2.9: &lexical + &i/o-read - char decoding error in get-datum
	 		   	     - intra-char EOF in get-datum
r6rs-lib 9: &i/o-filename - delete nonexistent or undeletable file
r6rs-lib 11.2: &implementation-restriction - fixnum arithmetic overflow
	       				   - fx+ or fx* overflow
					   - fx- overflow
	       &assertion		   - (fx- (least-fixnum))
	       &implementation-restriction - fxarithmetic-shift overflow
r6rs-lib 11.3: &no-infinities - if FPU can't represent Inf
	       *no-nans - if FPU can't represent NaN
r6rs-lib 12.4: &syntax  - (set! p.car 15)
r6rs-lib 12.5: &syntax  - (rec 5 (lambda (x) x))
	       		- (let ([a 3] [a 4]) (+ a a))
			- (let ([else #f])
			    (case 0 [else (write "oops")]))
r6rs-lib 12.9: &syntax  - raised by syntax-violation
r5rs-lib 14: &syntax    - (color purpel)
r6rs-lib 16: &syntax    - if eval passed a non-expression
	     	        - if eval passed a definition or splicing begin 
		          containing a definition
	     &assertion - if eval assigns to its environment
r6rs-lib 17: &assertion - (set-car! (g) 3)
	     		- if set-car! passed immutable pair
	     		- if set-cdr! passed immutable pair
r6rs-lib 18: &assertion - if string-st! passed immutable string
	     		- (string-set! (g) 0 #\?)
			- (string-set! (symbol->string 'immutable)
			               0
				       #\?)

----------------------------------
2010.01.31

More Scheme papers.  These are by Matt Might.
    Lexing with derivatives
    http://matt.might.net/articles/implementation-of-regular-expression-matching-in-scheme-with-derivatives/

    Compiling Scheme directly to Java
        http://matt.might.net/articles/compiling-to-java/

    Flat closure conversion while compiling to C
        http://matt.might.net/articles/compiling-scheme-to-c/

    Church encoding
        http://matt.might.net/articles/church-encodings-demo-in-scheme/

    First-class macros and meta-circular evaluators
        http://matt.might.net/articles/metacircular-evaluation-and-first-class-run-time-macros/


Other Scheme implementors who announced their projects on Scheme from Scratch
http://peter.michaux.ca/

    Peter Michaux (C, Scheme from Scratch series)
	git://github.com/petermichaux/bootstrap-scheme.git

    Jim Ingram (C)
	http://github.com/ingramj/bs

    Chris Salch (C)
	http://git.kc5vzm.com/?p=scheme;a=summary

    Nick Fitzgerald (Ada)
	http://github.com/fitzgen/ada-scheme

    Stu (C)
	git://github.com/stu/bootstrap-slip.git

    Chris Lloyd (Go)
	http://github.com/chrislloyd/go-scheme
	Seems to be abandoned early.

    Philipp (Java for Lego Mindstorms)
	http://github.com/toelke/scheme-nxj

    Matei Conovici
	http://github.com/cmatei/yalfs

    Franciso JosÃ© MarÃ­n PÃ©rez (pmarin)
	http://github.com/pmarin/Muddy-Scheme
	http://wiki.tcl.tk/25512

    kbob
        http://github.com/kbob/schetoo

---

Need to implement a handful of primitives before I can eval a
procedure call.  Peter Michaux started with quote, but I want a
procedure, not a syntax keyword.

Let's suppose we declare primitive procedures like this.

    DEFINE_PROC(L"+", 0-)(obj_t arglist)
    {
        word_t sum = 0;
        while (arglist != EMPTY_LIST) {
            sum += fixnum_value(CAR(arglist));
            arglist = CDR(arglist);
        }
	return make_fixnum(sum);
    }

    DEFINE_PROC(L"cons", 2)(obj_t car, obj_t cdr)
    {
        return CONS(car, cdr);
    }

Just like the old codebase, there will be three kinds of procs,
varying in their scope.  The default scope will be anonymous.

    #define DEFINE_PROC DEFINE_ANONYMOUS_PROC

    #define DEFINE_ANONYMOUS_PROC(scheme_name, arg_range) ...
    #define DEFINE_STATIC_PROC(C_name, scheme_name, arg_range) ...
    #define DEFINE_EXTERN_PROC(C_name, scheme_name, arg_range) ...

